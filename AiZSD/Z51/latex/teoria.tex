\section{Teoria}
\subsection{Opis Problemu}
Odległość edycyjna, znana także jako odległość Levenshteina, to popularna metoda do analizy i korekty tekstu, opracowana przez Vladimira Levenshteina w 1965 roku\cite{levenshtein1966}. Jest to uogólnienie odległości Hamminga, która mierzy odmienność między dwoma skończonymi ciągami znaków.

\vspace{1em}

Odległość ta jest zdefiniowana jako minimalna liczba prostych operacji potrzebnych do przekształcenia jednego ciągu w drugi. Dozwolone operacje to:

\begin{itemize}
    \item Zamiana znaku - zmiana jednego znaku na inny.
    \item Usunięcie znaku - usunięcie jednego znaku z ciągu.
    \item Dodanie znaku - wstawienie nowego znaku do ciągu.
\end{itemize}

\vspace{1em}

Każda z tych operacji ma taką samą wagę. Odległość Levenshteina jest miarą metryczną, co oznacza, że spełnia warunki metryki w przestrzeni ciągów znaków. 

\subsection{Rekurencyjna definicja}
Odległość Levenshteina można sformułować rekurencyjnie. Rekurencyjna definicja odległości edycyjnej \(d(x_1, x_2)\) między łańcuchami \(x_1\) i \(x_2\) jest następująca:

\vspace{1em}

Warunki brzegowe:
\begin{itemize}
    \item \(d(\epsilon, \epsilon) = 0\): Przekształcenie pustego łańcucha w pusty nie wymaga operacji.
    \item \(d(s, \epsilon) = |s|\): Przekształcenie łańcucha \(s\) w pusty wymaga usunięcia wszystkich znaków.
    \item \(d(\epsilon, s) = |s|\): Przekształcenie pustego łańcucha w \(s\) wymaga wstawienia wszystkich znaków.
\end{itemize}

Definicja rekurencyjna:
\[
    d(s_1z_1, s_2z_2) = \min 
    \begin{cases} 
        d(s_1, s_2) + \chi(z_1 \neq z_2), & \text{(zamiana)} \\ 
        d(s_1z_1, s_2) + 1, & \text{(usunięcie)} \\ 
        d(s_1, s_2z_2) + 1, & \text{(wstawienie)} 
    \end{cases}
\]
, gdzie \(\chi(z_1 \neq z_2)\) wynosi 0, jeśli znaki są takie same, i 1, jeśli są różne.

\subsection{Praktyczne zastosowania odległości edycyjnej}
Odległość Levenshteina znajduje szerokie zastosowanie w wielu dziedzinach informatyki i nie tylko. Poniżej przedstawiono kluczowe obszary jej wykorzystania:

\subsubsection*{Przetwarzanie języka naturalnego}
\begin{itemize}
    \item \textbf{Korekta pisowni:} Systemy sprawdzania pisowni używają odległości Levenshteina do sugerowania poprawek, określając najbliższe prawidłowe słowa.
    \item \textbf{Wyszukiwanie rozmyte:} Silniki wyszukiwania wykorzystują algorytm do znajdowania podobnych haseł, nawet przy małych błędach pisowni.
\end{itemize}

\subsubsection*{Bioinformatyka}
\begin{itemize}
    \item \textbf{Analiza sekwencji DNA:} Porównywanie sekwencji genetycznych, identyfikacja mutacji i podobieństw między łańcuchami genetycznymi.
    \item \textbf{Klasyfikacja białek:} Określanie stopnia podobieństwa strukturalnego między różnymi białkami.
\end{itemize}

\subsubsection*{Systemy bezpieczeństwa i weryfikacji}
\begin{itemize}
    \item \textbf{Weryfikacja tożsamości:} Porównywanie ciągów znaków w systemach identyfikacji, np. przy weryfikacji danych osobowych.
    \item \textbf{Systemy antyplagiatowe:} Wykrywanie podobieństwa między tekstami, identyfikacja zapożyczeń.
\end{itemize}

\subsubsection*{Technologie informacyjne}
\begin{itemize}
    \item \textbf{Systemy rekomendacyjne:} Dopasowywanie użytkowników lub treści poprzez pomiar podobieństwa.
    \item \textbf{Analiza błędów w kodzie:} Identyfikacja podobnych komunikatów o błędach lub fragmentów kodu.
\end{itemize}

\subsubsection*{Telekomunikacja i przetwarzanie sygnałów}
\begin{itemize}
    \item \textbf{Korekcja błędów transmisji:} Wykrywanie i naprawianie zniekształceń w przesyłanych danych.
    \item \textbf{Rozpoznawanie mowy:} Dopasowywanie wypowiedzianych słów do wzorców słownikowych.
\end{itemize}